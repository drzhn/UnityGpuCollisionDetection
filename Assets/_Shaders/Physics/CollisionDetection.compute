#pragma kernel CollisionDetection

#include <Assets/_Shaders/Constants.cginc>

RWStructuredBuffer<float3> _positionBuffer; // size = DATA_BLOCK_SIZE * THREADS_PER_BLOCK

StructuredBuffer<uint> _cellHash; // size = BLOCK_SIZE * THREADS_PER_BLOCK
StructuredBuffer<uint> _packedCellTypeControlAndIndex; // size = BLOCK_SIZE * THREADS_PER_BLOCK
StructuredBuffer<uint> _offsets; // size = BLOCK_SIZE * THREADS_PER_BLOCK

// we will apply collision detection and integration in 8 steps for each cell type;
uint _currentCellType;

struct ObjectData
{
    bool isHome;
    uint cellType;
    uint controlBits;
    uint objectIndex;
};

ObjectData UnpackObjectData(uint packed)
{
    ObjectData data;
    data.isHome = (packed >> 31) & ((1 << 1) - 1);
    data.cellType = (packed >> 28) & ((1 << 3) - 1);
    data.controlBits = (packed >> 20) & ((1 << 8) - 1);
    data.objectIndex = (packed >> 0) & ((1 << 20) - 1);
    return data;
}

[numthreads(THREADS_PER_BLOCK,1,1)]
void CollisionDetection(uint3 tid : SV_DispatchThreadID)
{
    const uint id = tid.x;
    const uint lastIndex = THREADS_PER_BLOCK * BLOCK_SIZE - 1;
}
